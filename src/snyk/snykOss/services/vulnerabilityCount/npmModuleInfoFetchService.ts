import _ from 'lodash';
import { IConfiguration } from '../../../common/configuration/configuration';
import { ErrorHandler } from '../../../common/error/errorHandler';
import { ILog } from '../../../common/logger/interfaces';
import { NpmTestApi } from '../../api/npmTestApi';
import { ImportedModule, TestedImportedModule } from './importedModule';

export type NpmRegistryPackage = {
  name: string;
  version: string;
};

export type NpmTestApiResult = {
  resultTitle: string;
  totalVulns: number;
};

/**
 * Responsible for caching & fetching npm module info
 */
export class NpmModuleInfoFetchService {
  private readonly debounceIntervalInMs = 2000;

  private debouncedPromises: Record<string, (...args: unknown[]) => Promise<number>> = {};

  private npmPackageCache = new Map<string, NpmRegistryPackage>();
  private vulnerabilityCountCache = new Map<string, number | Promise<number>>();

  constructor(
    private readonly config: IConfiguration,
    private readonly logger: ILog,
    private readonly npmTestApi: NpmTestApi,
  ) {}

  async getModuleVulnerabilityInfo(module: ImportedModule): Promise<TestedImportedModule> {
    const key = this.getVulnerabilityCacheKey(module);
    if (!key) {
      return { ...module, tested: false };
    }

    const cachedVulnCount = this.vulnerabilityCountCache.get(key);
    if (cachedVulnCount === undefined || cachedVulnCount instanceof Promise) {
      try {
        const vulnCount = await (cachedVulnCount || this.lookupVulnerabilities(key, module.string));
        this.vulnerabilityCountCache.set(key, vulnCount);
      } catch (e) {
        this.logger.info(`Failed to lookup vulnerabilities for ${key}. ${e}`);
        this.vulnerabilityCountCache.delete(key);
        return { ...module, tested: false };
      }
    }

    const result = await this.vulnerabilityCountCache.get(key);
    if (!result) {
      throw new Error(`Vulnerability result isn't available for ${key} due to missing cache entry.`);
    }

    return { ...module, vulnerabilityCount: result, tested: true };
  }

  private getVulnerabilityCacheKey(module: ImportedModule): string | undefined {
    try {
      const npmPackage = this.getNpmRegistryPackage(module);
      return `${npmPackage.name}@${npmPackage.version}`;
    } catch (e) {
      this.logger.error(ErrorHandler.stringifyError(e));
      return undefined;
    }
  }

  private getNpmRegistryPackage(module: ImportedModule) {
    if (!module.string) {
      throw new Error('Module source string must be provided to work with npm package cache.');
    }
    if (!module.version || !module.name) {
      throw new Error('Module name and version must be provided to fetch a package.');
    }

    const npmPackage = this.npmPackageCache.get(module.string) || { name: module.name, version: module.version };
    this.npmPackageCache.set(module.string, npmPackage);

    return npmPackage;
  }

  private lookupVulnerabilities(vulnerabilityKey: string, npmPackageCacheKey: string): Promise<number> {
    const npmPackage = this.npmPackageCache.get(npmPackageCacheKey);
    if (!npmPackage) {
      throw new Error('Npm package is not in cache for some reason.');
    }

    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    return this.debouncePromise(vulnerabilityKey, this.test.bind(this), npmPackage);
  }

  private async test(npmPackage: NpmRegistryPackage): Promise<number> {
    return this.npmTestApi.getPackageVulnerabilityCount(npmPackage.name, npmPackage.version);
  }

  private async debouncePromise(
    name: string,
    fn: (...args: unknown[]) => Promise<number>,
    ...args: unknown[]
  ): Promise<number> {
    if (!this.debouncedPromises[name]) {
      const debounced = _.debounce((resolve, reject, args) => {
        /* eslint-disable @typescript-eslint/no-unsafe-argument */
        fn(...args)
          .then(resolve)
          .catch(reject);
        /* eslint-enable @typescript-eslint/no-unsafe-argument */
      }, this.debounceIntervalInMs);

      this.debouncedPromises[name] = (...args): Promise<number> =>
        new Promise((resolve, reject) => {
          debounced(resolve, reject, args);
        });
    }

    return this.debouncedPromises[name](...args);
  }
}
